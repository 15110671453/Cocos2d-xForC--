C/C++输入/输出重定向
前言
　　在我学习C语言的初期，一直有个麻烦，因为打印的调试或者结果信息过多，一屏显示不下，所以很多时候我看不到前面打印出来的信息，唯一的方法就是不停地按CTRL+ALT+PAUSE组合键来暂停输出~~~有心要把它改成文件输出吧，想到要一个一个地把printf改成fprintf（那时还不懂文本编辑工具），又怕了。真想有个简单有效的办法！！！后来才知道，有个东西叫重定向———
　　是什么
　　所谓重定向就是把某应用原来的操作对象改成别的。比如说，我这个程序原来是从键盘接收信息的，现在该从一个叫config.ini的文件中接收信息了；本来输出的信息都显示在屏幕上的，现在我不显示在屏幕上了，我要输出到result.txt文本中保存起来。
　　怎么做
　　方法一：freopen
　　如果你手中有源代码的话，你只需要在代码的前面加一句话：
　　FILE *stream;
　　stream = freopen( "out.txt", "a+", stdout );
　　就行了。这样，你就把程序中原定输出到屏幕的信息重定向到out.txt中了,且不覆盖out.txt中的内容，只是把新的输出追加在文件尾。这是一个ANSI C函数，所以是跨平台的。具体可以参考MSDN。
　　方法二、管道命令
　　如果非常不幸地，你只有可执行文件，而没有源代码可以修改，操作系统为你提供了管道命令。在windows cmd命令中有两个管道命令是专门用来进行I/O重定向的。
　　1. >,>>输出重定向命令
　　将一条命令或某个程序输出结果的重定向到特定文件中, > 与 >>的区别在于，>会清除调原有文件中的内容后写入指定文件，而>>只会追加内容到指定文件中，而不会改动其中的内容。
　　2. < , >& , <&输入重定向命令
　　< 从文件中而不是从键盘中读入命令输入。
　　>& 将一个句柄的输出写入到另一个句柄的输入中。
　　<& 从一个句柄读取输入并将其写入到另一个句柄输出中。
　　有了这两个，我如果想把程序中原定输出到屏幕的信息重定向到out.txt,且只追加不覆盖原有内容的话，就可以这样做：
　　command(程序名) >> out.txt
　　更进一步地，如果我想把原来打印到stderr和stdout的信息全部重定向到一个文件out.txt中，也可以：
　　command(程序名) >> out.txt  1>&2
　　这里的1和2分别是stdout和stderr在系统中的句柄，有：
　　STDIN      0 键盘输入
　　STDOUT    1 输出到命令提示符窗口
　　STDERR    2 错误输出到命令提示符窗口
　　扩展： T型管道
　　更过分地，如果既想能够实时从屏幕上看到信息，又想能够把信息存储到一个文件中备案的话怎么办？海涛的专栏【3】中提出了在windows系统中模拟UINX命令tee的想法。命令tee就像它的名字一样，充当管道T型接头。将输出分成两个流，一个流到文件中，另一个仍然输出到屏幕上去。真是非常形象的说法！海涛还给出了程序，但是不知道什么原因，该程序在我的机子上达不到效果，所以我对程序进行了一些小的改动，达到了目的。下面给出程序清单：
　　#include  <stdio.h>
　　int main(int argc, char **argv)
　　{
　　FILE *fp;
　　int c;
　　if ( argc > 1 ) 
　　{
　　fp = fopen(argv[1], "wa");
　　if ( fp == NULL ) 
　　{
　　fprintf(stderr, "%s: can not open <%s>\n", argv[0], argv[1]);
　　return -1;
　　}
　　}
　　else
　　{
　　fp = stdout;
　　}
　　while ( (c = fgetc(stdin)) != EOF )
　　{
　　fputc(c,fp);
　　if (fp != stdout)
　　{
　　fputc(c,stdout);
　　}
　　}
　　return 0;
　　}
　　把上面这个程序编译连接生成tee.exe文件后，只要使用命令：
　　command(程序名) | tee  out.txt
　　就可以达到目的了。
　　最后说明一下，上面的 | 也是一个管道运算符，它可以捕获命令的输出并作为下一个命令的输入发送。具体可以参考后面列出的参考资源。