//
//  ConstantsProject.pch
//  HelloWorldDemo
//
//  Created by admindyn on 2017/8/11.
//
//

#ifndef ConstantsProject_pch
#define ConstantsProject_pch

// Include any system framework and library headers here that should be included in all compilation units.
// You will also need to set the Prefix Header build setting of one or more of your targets to reference this file.


/*
 第一 
 
 在C++ 中 对类对象的声明
 类名  对象名表
 CPerson p;声明一个对象
 CPerson p,p1; 声明多个对象
 
 
 
 声明完对象 就是对象的引用 包括两个方面 一种是
 成员引用方式；另一种是对象指针方式 取决于声明对象时的策略
 
 我们采用声明一个对象指针
 CPerson* p 想要引用成员 p->index p->func(arg) 使用-> 运算符 操作符
 
 我们使用一般类对象声明
 CPerson p 想要引用成员 p.index p.func(arg)
 
 类的构造函数 有参数的构造函数 复制构造函数(与普通构造函数区别 复制构造函数参数是一个已经初始化的类对象)
 ---------
 静态类成员 可以通过类名访问 定义静态类成员时需要初始化
 
 静态成员函数 末尾不能使用 const关键字 而普通成员函数 后面可以加const关键字 表示没有对对象的成员变量做修改
 
 静态成员函数只能访问类的静态数据成员 不能访问普通的数据成员
 
 声明 静态成员函数时 函数前加static 在实现文件中 定义静态成员函数时 不能使用static关键字 
 ---------
 对于类的非静态成员 每一个对象都有自己的一份拷贝 即每个对象都有自己的数据成员 
 但是成员函数 却是每个对象共享的 那么调用成员函数时如何找到自己的数据成员 就是通过类中隐藏的this指针 等同于OC语言中的self
 ---------
 
 友元 机制 使用friend机制 让特定的函数或者别的类的成员函数对自己的私有数据成员进行读写 否则只能借助自己的public共有函数 操作想要的数据成员 无法直接操作（p.index）
 
 --------
 
类的继承 与 派生 ；继承与派生从不同角度说明类之间的关系 这种关系包含 访问机制 多重继承 和 重载；
 
 继承：用已有的数据类型创建新的数据类型，并保留已有数据类型的特点；以旧类为基础创建新类，新类包含了旧类的数据成员和成员函数，并且可以在新类中添加新的数据成员和成员函数。旧类被称为基类或父类，新类被称为派生类或子类
 
 这里 继承声明 类名 冒号运算符 继承方式 父类名字列表（C++多继承）
 
 子类继承 父类的所有非私有成员（private 类型成员不能被继承 子类无法访问这些成员）；
 子类继承 父类 在子类中定义一个与父类同名的成员函数 此时 子类 隐藏了父类的成员函数 ；称之为重写吧；
 子类 一旦隐藏了父类的成员函数
 子类在（直接）调用时 只调用子类的成员函数 不调用父类的同名成员函数（这里是所有的同名成员函数 （即包括哪些重载的））
 
 但临时想调用父类的 怎么办
 
 COperator optr;
 optr.OutputName();这样只调用当前子类的方法
 optr.CEmployee::OutputName();这样就可以调用到父类的同名成员方法了
 
 -------
 继承 --构造函数的访问顺序   当从父类派生一个子类并声明一个子类的对象时，它将先调用父类的构造函数 然后调用当前类的构造函数来创建对象；在释放子类对象时，先调用当前类的析构函数，再调用父类的析构函数
 
 类中 析构函数 是虚函数吗；（默认不是 当我们实现一个准备继承的父类时 父类的析构函数 最好定义为虚函数 virtual 因为 当我们用 基类指针或引用 指向一个 派生类对象时 并无违反C++语法 ，此时该指针可以调用子类与父类的同原型的成员函数，而此时只执行父类的，如果想调用子类的 需要 将该方法定义为虚函数 避免子类为某个数据成员在堆中分配了空间，父类中的析构函数不是虚成员函数 将使是子类的析构函数不被调用，其结果是对象不能被正确释放，导致内存泄漏 （我们这里引起这种情况的原因 就是：定义一个基类类型的指针，调用子类的构造函数为其构建对象造成的））
 
 我们都是 子类继承父类 子类可以（直接）调用从父类继承的非同名的成员函数
 
 但是如何父类 （直接）调用 子类的成员函数呢
 C++通过虚函数可以实现
 
 首先该父类对象不是直接父类构造 而是父类对象 借助子类对象构造 然后可以虚函数调用方法
 
 即 在派生完一个类后 定义一个父类的类型指针 通过子类的构造函数为其创建对象(COperator 是 CEmployee的子类)
 CEmployee*pWorker=new COperator；
 
 该指针 如果调用子类重命名的成员函数 调用的是 父类的实现！！！！
 
 同样可以通过虚函数的方式 该指针可以调用到子类的重命名后的实现
 -----------
 
 c++重载运算符的意义
 
 一般运算符 由于c++中的数据类型 分为 基础数据类型与构造数据类型
 
 一般运算符只能操作基础数据类型完成算术运算
 
 重载规则：不能改变运算符操作数的个数 ，不能改变运算符原有的优先级，不能改变运算符原有的结合性，不能改变运算符原有的语法结构，即单目运算符只能重载为单目运算符，双目运算符只能重载为双目运算符
 --------
 c++多态
 多态是通过计算机联编实现的 联编是指一个计算机程序自身彼此的关联的过程
 联编所进行的阶段不同可以分为两种不同的联编方法：静态联编和动态联编 ；
 在c++中根据联编的时刻不同存在两种类型的多态性
 第一 通过 函数重载实现
 （在类的继承层次结构中 在不同的层次中可以出现名字、参数个数和类型都相同而功能不同的函数 ；编译器按照先自己后父类的顺序进行查找覆盖，如果子类有父类相同原型的成员函数时，要想调用父类的成员函数，需要对父类重新引用调用）
 第二 通过 虚函数 实现
 （虚函数 更强大 它可以解决子类和父类相同原型成员函数的函数调用问题。虚函数允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数[规则 如果派生类没有重写 则该基类指针 就调用父类的实现 如果派生类重写了 因为是虚函数 所以 该基类指针 调用子类的实现]）
 
 
 */

#endif /* ConstantsProject_pch */
